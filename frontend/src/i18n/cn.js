/********************************************************************************
 * Copyright (c) 2020, 2022 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0
 *
 * SPDX-License-Identifier: EPL-2.0
 ********************************************************************************/
'use strict';

exports.__esModule = true;
exports.default = {
  jifa: {
    searchTip:"搜索文本使用Java语言正则语法，比如用 *.String.* 来搜索java.lang.String，搜索数值使用>num,<num,>=num,<=num,==num,!=num,num的语法",
    searchPlaceholder:'搜索...',
    heapDumpAnalysis: '堆分析',
    gclogAnalysis: 'GC日志分析',

    unlockFileSuccessPrompt:'解锁成功！',
    unlockFilePrompt:'是否解锁文件，允许任意用户访问?',
    unlockFile:'解锁文件',
    setting: '设置',
    diskCleanup: '清理磁盘',
    help: '帮助',
    consoleMsg: '',
    getStarted: '开始使用',
    success: '成功',
    console: '控制台',
    qm: '？',
    feedback: '建议与反馈',
    options: '选项',
    optionsWithHelp: '选项',
    close: '关闭',
    uploadPrompt: '选择文件(拖拽或点击选择)',
    enterPrompt: '请输入',
    inLine: '排队中',
    addFile: '添加文件',
    addHeapDumpFile:'添加 Heap Dump',
    addGCLogFile: '添加 GC 日志',
    copy: '复制',
    copySuccessfully: '复制成功',
    requestFailed: '请求失败',
    config: '配置',
    prompt: '提示',
    confirm: '确定',
    reset: '重置',
    cancel: '取消',
    fileTransfer: '文件传输',
    progress: '进度',
    analyze: '分析',
    reanalyze: '重新分析',
    release: '释放',
    download: '下载原文件',
    edit: '编辑',
    delete: '删除',
    loading: '加载中',
    goToOverViewPrompt: '即将进入概况页面...',
    deletePrompt: '此操作将永久删除该文件，是否继续？',
    deleteSuccessPrompt: '删除成功！',
    deleteFailedPrompt: '删除失败！',
    deleteCanceled: '已取消删除',
    downloadBegin: '文件开始下载，请耐心等待',
    returnValue: '确定离开吗?',
    gotoParseFile: '即将解析文件',

    typeKeyWord: '输入关键字搜索',

    transferring: '传输中',
    transferError: '传输失败',

    show: '显示',
    hide: '隐藏',

    expandResultDivWidth: '显示宽度 Expand',
    shrinkResultDivWidth: '显示宽度 Shrink',
    resetResultDivWidth: '显示宽度 Reset',

    backToHome: '返回主页',
    promote404: '您所寻找的页面不存在。可以点击下面的按钮，返回主页。',

    tip: {
      copyName: '复制文件名',
      rename: '修改文件名',
      uploadToOSS: '上传文件到OSS',
      setShare: '设置文件共享',
      deleteFile: '删除文件',
      downloadFile: '本地下载文件，最大支持512MB',
    },

    heap: {
      basicInformation: '基础信息',
      reanalyzePrompt: '是否继续？',
      releasePrompt: '是否继续？',
      overview: '概况',
      leakSuspects: '泄露报表',
      description: '描述',
      detail: '细节',
      GCRoots: 'GC 根对象',
      systemProperty: '系统属性',
      OSBit: '操作系统位数',
      jvmInfo: 'JVM',
      heapCreationDate: '创建时间',
      usedHeapSize: '堆使用大小',
      numberOfClasses: '类数量',
      numberOfObjects: '对象数量',
      numberOfClassLoaders: '类加载器数量',
      numberOfGCRoots: '根对象数量',
      threadInfo: '线程信息',
      dominatorTree: '支配树',
      histogram: '类视图',
      unreachableObjects: '不可达类视图',
      duplicatedClasses: '重复类视图',
      classLoaders: '类加载器视图',
      directByteBuffer: '堆外内存视图',
      compare: '内存文件对比',
      ref: {
        object: {
          label: '对象引用',
          outgoing: '引用对象集合',
          incoming: '被引用对象集合',
        },
        type: {
          label: '类型引用',
          outgoing: '引用类型集合',
          incoming: '被引用类型集合',
        }
      },

      pathToGCRoots: 'GC 根路径',
      mergePathToGCRoots: '合并GC 根路径',

      descOfKeepUnreachableObjects: '如果启用此选项，分析器会将不可达对象视为不可达根，进而分析其中的引用关系。 否则，将不对不可达对象进行进一步的分析，仅统计类型信息，即不可达类视图',
      descOfStrictness: '\'strictness\' 表示当分析过程中遇到错误时的后续动作',
      descOfStopStrictness: '终止分析',
      descOfWarnStrictness: '报告警告信息并继续分析',
      descOfPermissiveStrictness: '报告警告信息，尝试修复错误并继续分析',
    },

    gclog: {
      fileNotExist: '文件不存在',
      gclogFile: "GC日志文件",
      navigation: '导航',
      navToTop: '回到最上方',
      gclogFilePlaceholder: "填写文件分析页面的URL，如果要选择分析的时间段请在文件分析页面里先配置好",
      stwTooltip: "程序在这个阶段会暂停(stop the world)",
      showGCDetail: '显示GC详情',
      analysisConfig: '分析配置',
      gclogCompare: 'GC日志对比',
      logTimeRange:"日志覆盖的时间段",
      analysisTimeRange:"当前分析的时间段",
      duration: "时长",
      analysisTimeRangeChooseHint:"选择一个你关心的时间段，分析这个时间段内的GC情况",
      analysisTimeRangeLength:"分析时间段长度",
      metric: "指标",
      metricCompare: "指标对比",
      parallelGCThreads:'GC并行线程数',
      parallelGCThreadsHint:'GC并行线程(对应参数-XX:ParallelGCThreads)用于处理所有暂停阶段的工作，增大线程数可以减少GC暂停时间，但不要超过CPU数量。',
      concurrentGCThreads:'GC并发线程数',
      concurrentGCThreadsHint:'GC并发线程(对应参数-XX:ConcGCThreads)用于所有并发阶段的工作，增大线程数可以让并发GC更快完成，但是会提高并发GC过程中的CPU利用率',
      gcDetail: 'GC详情',
      applyTimeToConfig: "将当前所选时间段应用到整个页面",
      noDatestamp: '日志中没有展示GC发生的现实时间，只能根据相对于日志开始的时间进行搜索。强烈建议打开显示GC发生现实时间的选项。',
      longPauseThreshold: '长暂停时间阈值(ms)',
      longPauseThresholdHint: '超过这个时长的暂停会被视为长暂停',
      youngGCFrequentIntervalThreshold: 'Young GC 间隔阈值(ms)',
      youngGCFrequentIntervalThresholdHint: '如果两次Young GC之间的间隔少于这个时间则认为Young GC发生的较为频繁',
      oldGCFrequentIntervalThreshold: 'Old GC 间隔阈值(ms)',
      oldGCFrequentIntervalThresholdHint: '如果两次Old GC之间的间隔少于这个时间则认为Old GC发生的较为频繁',
      fullGCFrequentIntervalThreshold: 'Full GC 间隔阈值(ms)',
      fullGCFrequentIntervalThresholdHint: '如果两次Full GC之间的间隔少于这个时间则认为Full GC发生的较为频繁',
      fullGCForNongenerational: '由于{gc}是不分代的GC算法，所有的GC都被视为Full GC',


      basicInfo: '基本信息',
      collector:"收集器",
      objectStats: '对象统计',
      objectCreationSpeed: "对象创建速度",
      objectPromotionSpeed: "对象晋升速度",
      objectPromotionAvg: "平均对象晋升大小",
      objectPromotionMax: "最大单次对象晋升大小",

      pauseInfo: {
        pauseInfo: "暂停信息",
        pauseDistribution: "暂停时间分布",
        throughput: "GC吞吐",
        throughputHint:"GC吞吐是程序实际执行的时间/总运行时间，吞吐率越高意味着GC开销越小",
        pauseAvg: "平均暂停时间",
        pauseMax: "最大暂停时间",
        pauseMedian: "暂停时间中位数",
        pauseTime: "暂停时间",
        pauseCount: "暂停次数"
      },

      memoryStats: {
        memoryStats: "堆和元空间统计",
        memoryArea: "内存区域",
        capacityAvg: "平均容量",
        capacityAvgHint: "容量表示这个区域能最大容纳多少对象。平均容量有可能会比最大使用量更小，原因在于容量可以是动态变化的，比如当-Xmx!=-Xms时堆和年轻代老年代的容量会动态变化",
        g1DynamicCapacity: "此外，G1如果没有设-Xmn(通常也不推荐设Xmn)的话年轻代和老年代大小也是动态的",
        usedMax: "最大使用量",
        usedMaxHint: "可以用来评估java进程整体内存占用的RSS，其中堆所占的大小比较接近堆历史上最高使用量",
        usedAvgAfterFullGC: "Full GC后平均使用量",
        usedAvgAfterFullGCHint: "用于估算这个区域大概有多少常驻的对象，如果这个值较高，说明应用在该区域存在内存泄露的可能性",
        usedAvgAfterOldGC: "Old GC后平均使用量",
        usedAvgAfterOldGCHint: "用于估算这个区域大概有多少常驻的对象，如果这个值较高，说明应用在该区域存在内存泄露的可能性",
        metaspaceCapacity: "注意原始GC日志中打印的类似 'Metaspace: 1792694K->291615K(698368K)' 的信息表示元空间reserve的空间是698368K,而非真正的容量",
        youngCapacityAvg: '年轻代平均容量',
        youngUsedMax: '年轻代最大使用量',
        oldCapacityAvg: "老年代平均容量",
        oldUsedMax: "老年代最大使用量",
        oldUsedAvgAfterFullGC: "老年代在Full GC后平均使用量",
        oldUsedAvgAfterOldGC: "老年代在Old GC后平均使用量",
        humongousUsedMax: "大对象最大使用量",
        humongousUsedAvgAfterFullGC: "大对象在Full GC后平均使用量",
        humongousUsedAvgAfterOldGC: "大对象在Old GC后平均使用量",
        heapCapacityAvg: "整堆平均容量",
        heapUsedMax: "整堆最大使用量",
        heapUsedAvgAfterFullGC: "整堆在Full GC后平均使用量",
        heapUsedAvgAfterOldGC: "整堆在Old GC后平均使用量",
        metaspaceCapacityAvg: "元空间平均容量",
        metaspaceUsedMax: "元空间最大使用量",
        metaspaceUsedAvgAfterFullGC: "元空间在Full GC后平均使用量",
        metaspaceUsedAvgAfterOldGC: "元空间在Old GC后平均使用量",
      },

      phaseStats: {
        phaseStatsAndCause: "GC阶段和原因",
        phaseStats: "GC阶段",
        importantMode: "只显示重要的阶段",
        pauseMode: "只显示暂停的阶段",
        structuredMode: "按层次显示阶段",
        causeMode: "按GC原因显示",
        name: "名称",
        count: "发生次数",
        intervalAvg: "平均间隔",
        intervalMin: "最小间隔",
        durationAvg: "平均时长",
        durationMax: "最大时长",
        durationTotal: "总时长",
        youngGCCount:'Young GC次数',
        youngGCIntervalAvg:'Young GC平均间隔',
        youngGCDurationAvg:'Young GC平均时长',
        youngGCDurationMax:'Young GC最大时长',
        mixedGCCount:'Mixed GC次数',
        mixedGCIntervalAvg:'Mixed GC平均间隔',
        mixedGCDurationAvg:'Mixed GC平均时长',
        mixedGCDurationMax:'Mixed GC最大时长',
        oldGCCount:'Old GC次数',
        oldGCIntervalAvg:'Old GC平均间隔',
        oldGCDurationAvg:'Old GC平均时长',
        oldGCDurationMax:'Old GC最大时长',
        fullGCCount:'Full GC次数',
        fullGCIntervalAvg:'Full GC平均间隔',
        fullGCDurationAvg:'Full GC平均时长',
        fullGCDurationMax:'Full GC最大时长',
      },

      generation: {
        young: "年轻代",
        old: "老年代",
        humongous: "大对象",
        humongousHint: "G1的大对象指的是大小超过HeapRegionSize一半的对象",
        heap: "整堆",
        metaspace: "元空间",
      },

      vmOptions: {
        vmOptions: "JVM参数",
        unknown: "在GC日志中没有出现",
        gcRelatedOptions: "GC相关参数",
        otherOptions: "其它参数",
      },

      timeGraph: {
        timeGraph: '时间图',
        fullScreen: '切换全屏显示',
        durationOf: '{type}时长',
        youngCapacity: '年轻代容量',
        oldUsed: '老年代使用',
        oldCapacity: '老年代容量',
        humongousUsed: '大对象使用',
        heapUsed: '堆使用',
        heapCapacity: '堆容量',
        metaspaceUsed: '元空间使用',
        metaspaceCapacity: '元空间容量',
        reclamation: '内存回收',
        promotion: '对象晋升',
      },

      cause:{
        systemgc: '调用System.gc()或Runtime.getRuntime().gc()时触发',
        jvmti: '使用Jvmti时调用ForceGarbageCollection触发',
        gclocker: '如果线程执行在JNI临界区时，刚好需要进行GC，此时GC Locker会阻止 GC的发生，同时阻止其他线程进入JNI临界区，直到最后一个线程退出临界区时触发',
        heapInspection: '当你使用工具(如jmap)执行堆检查操作时会触发',
        heapDump: '执行Heap Dump前会触发一次Full GC',
        allocationFail: '对象分配空间不足时触发，这是最常见的GC触发原因',
        metaspace: 'Metaspace空间不足时触发',
        ergonomics: '是为了调整堆的大小，从而达到某种暂停时间或吞吐量目标',
        g1Evacuation: '对象分配空间不足时触发，这是最常见的GC触发原因',
        humongous: 'G1大对象分配失败时触发Full GC。大对象指的是超过大小Heap Region Size一半的对象',
        lastDitch: '在Metadata GC Threshold GC后，空间依然不足，就会再次触发Full gc并清除弱引用',
        promotionFail: '在Young GC过程中，如果老年代没有足够的空间提供晋升，那么这次GC就会变成Full GC',
        toSpaceExhausted: '在Young GC过程中，没有足够的region作为to space或用来晋升的现象称为To-space exhausted，这会导致空间无法正常释放或者Young GC的时间大幅度拉长',
        proactive: 'JVM主动触发GC来减少堆内存占用，通常只在对象分配速率很低时进行',
        allocationRate: '当JVM根据当前的对象分配速度估计内存即将耗尽，就会触发一次GC',
        timer: '定期触发的GC',
        allocationStall: '当堆使用率已满无法分配对象时触发',
        highUsage: '堆的水位超过一定的百分比，就会触发一次GC',
        warmup: 'JVM启动之后，如果一直没有发生过GC，那么会在堆内存使用超过10%、20%、30%时，分别触发一次GC',
        metaspaceClearSoftRef: '在Metadata GC Threshold GC后，空间依然不足，就会再次触发Full gc并清除弱引用',
        g1Periodic: "在设置了-XX:G1PeriodicGCInterval，如果超过了该参数的时长都没有触发GC则主动触发一次GC，通常这个特性用于进行堆内存的回收",
        dcmd: "通过jcmd命令触发的Full gc",
        g1Compaction: 'G1 Full gc',
        g1Preventive: 'JVM会根据当前的内存使用和分配情况，提前触发gc来防止出现To-space exhausted',
      },

      diagnose: {
        diagnose: "问题诊断",
        noProblem: "暂无发现问题",
        problemTemplate: "当前时间段在{time}存在{problem}的情况",
        solution: "常见排查和调优方法：",
        abnormal: {
          outOfMemory: "Out of Memory",
          allocationStall: "Allocation Stall(对象分配暂停)",
          metaspaceFullGC: "Metaspace满导致Full GC",
          heapMemoryFullGC: "堆内存或者老年代满导致的Full GC",
          longYoungGCPause: "Young GC长暂停",
          systemGC: "调用System.gc()导致的Full GC",
        },
        suggestion: {
          upgradeTo11G1FullGC: "如果实在没办法消灭Full GC或者认为Full GC是可以接受的，可以考虑到升级到JDK11的G1 GC，JDK11中G1的Full GC改成了多线程进行，能大幅减少暂停时间",
          checkSystemGC: "检查一下System.gc()是在哪里调用的，是否有必要",
          disableSystemGC: "可以增加参数 -XX:+DisableExplicitGC 来彻底关闭System.gc()",
          oldSystemGC: "或者考虑增加参数 -XX:+ExplicitGCInvokesConcurrent 使得调用System.gc()触发一次并发的Old GC",
          checkMetaspace: "排查一下Metaspace中到底是哪些对象将空间占满了",
          enlargeMetaspace: "增大MetaSpace空间 -XX:MetaspaceSize -XX:MaxMetaspaceSize",
          enlargeHeap: "增大堆空间 -Xmx -Xms",
          increaseConcGCThreads: "适当提高并发GC线程数 -XX:ConcGCThreads",
          decreaseIHOP: "适当减小参数 -XX:InitiatingHeapOccupancyPercent, 使得Old GC更早发生",
          decreaseCMSIOF: "适当减小参数 -XX:CMSInitiatingOccupancyFraction, 使得CMS GC更早发生",
          increaseZAllocationSpikeTolerance: "适当增加参数 -XX:ZAllocationSpikeTolerance,使得GC更早发生",
          checkLiveObjects: "如果Young GC时的活对象多导致活对象拷贝时间长或者引发跨代引用，那么考虑排查一下应用逻辑，为什么会有那么多活对象",
          checkReferenceGC: "如果是Reference Processing时间长，考虑开启-XX:+ParallelRefProcEnabled多线程优化，或者排查为何有这么多Weak/Soft/Phatom Reference",
          checkCPUTime: "检查GC的CPU Time，如果Real时间长而usr，sys时间短，可能是磁盘IO或者同一宿主机上不同进程或容器互相干扰导致的",
          shrinkYoungGen: "考虑适当减小参数-Xmn，来减少年轻代大小",
          shrinkYoungGenG1: "考虑适当减小参数-XX:G1MaxNewSizePercent，来减少年轻代大小",
          checkEvacuationFailure: "如果GC出现了To-space exhausted的情况，会大幅拉长GC暂停，解决方法一方面是G1尽量不要设Xmn参数，另一方面考虑排查是否存在内存泄露或者晋升过快等情况",
          checkMemoryLeak: "通过Heap Dump等方式排查是否存在内存泄露的情况",
        }
      },

      detail:{
        filters:"筛选条件",
        eventType:"GC 事件类型",
        logTime:"日志时间",
        pauseTime:"暂停时间",
      },
    },

    threadDump: {
      title: "线程分析",
      addFile: "添加 Thread Dump",
      overview: '概览',
      lockView: '锁视图',
      basicInfo: '基础信息',
      threadSummary: "线程概要",
      time: '时间',
      vmInfo: '虚拟机',
      jniRefs: 'JNI References',
      jniWeakRefs: 'JNI Weak References',
      errorPrompt: '解析过程中产生的错误数：',
      deadLockCount: '死锁数量',
      threadGroupSummary: "线程池概要",
      javaThread: "Java Thread",
      jitThread: "JIT Thread",
      gcThread: "GC Thread",
      otherThread: "Other Thread",
      total: "Total",
      callSiteTree: "调用栈",
      fileContent: "文件内容",
      loadFileContent: "加载",
      loadMoreFileContent: "加载更多",
      threadNameLabel: "线程名",
    }
  }
};
