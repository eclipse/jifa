/********************************************************************************
 * Copyright (c) 2020, 2022 Contributors to the Eclipse Foundation
 *
 * See the NOTICE file(s) distributed with this work for additional
 * information regarding copyright ownership.
 *
 * This program and the accompanying materials are made available under the
 * terms of the Eclipse Public License 2.0 which is available at
 * http://www.eclipse.org/legal/epl-2.0
 *
 * SPDX-License-Identifier: EPL-2.0
 ********************************************************************************/
'use strict';

exports.__esModule = true;
exports.default = {
  jifa: {
    searchTip:'Use Java regex for text searching(such as matching java.lang.String with the regex pattern .*String.* ). Use >num,<num,>=num,<=num,!=num,num for numeric searching',
    searchPlaceholder:'Search...',
    heapDumpAnalysis: 'Heap Dump Analysis',
    gclogAnalysis: 'GC Log Analysis',

    unlockFileSuccessPrompt:'Unlock successfully!',
    unlockFilePrompt:'Are you sure unlocking this file to allow arbitrary access?',
    unlockFile:'Unlock File',
    setting: 'Setting',
    diskCleanup: 'Disk Cleanup',
    help: 'Help',
    consoleMsg: '',
    getStarted: 'Get Started',
    success: 'Success',
    console: 'Console',
    qm: '?',
    feedback: 'Feedback',
    options: 'Options',
    optionsWithHelp: 'Options',
    close: 'Close',
    uploadPrompt: 'Choose your file (drag or click)',
    enterPrompt: 'Please enter ',
    inLine: 'In Line',
    addFile: 'Add File',
    addHeapDumpFile:'Add Heap Dump File',
    addGCLogFile: 'Add GC Log File',
    copy: 'Copy',
    copySuccessfully: 'Copy Successfully',
    requestFailed: 'Request failed',
    config: 'Config',
    prompt: 'Prompt',
    confirm: 'Confirm',
    reset: 'Reset',
    cancel: 'Cancel',
    fileTransfer: 'File Transfer',
    progress: 'Progress',
    analyze: 'analyze',
    reanalyze: 'Reanalyze',
    release: 'release',
    download: 'Download File',
    edit: 'edit',
    delete: 'Delete',
    loading: 'Loading',
    goToOverViewPrompt: 'Go to the overview page',
    deletePrompt: 'This will permanently delete the file. Do you want to continue?',
    deleteSuccessPrompt: 'Delete success!',
    deleteFailedPrompt: 'Delete failed!',
    deleteCanceled: 'Delete operation is canceled',
    downloadBegin: 'Downloading has began. Please wait',
    returnValue: 'Are you sure to leave?',
    gotoParseFile: 'Will go to parse file',

    typeKeyWord: 'type key word to search',

    transferring: 'transferring',
    transferError: 'transfer error',

    show: 'Show',
    hide: 'Hide',

    expandResultDivWidth: 'Expand Width',
    shrinkResultDivWidth: 'Shrink Width',
    resetResultDivWidth: 'Reset Width',

    addResultDivWidth: 'Add width',

    backToHome: 'Back to home',
    promote404: 'The page you request was not found, you can click the following button to go to home page.',

    tip: {
      copyName: 'Copy file name',
      rename: 'Rename file name',
      uploadToOSS: 'Upload file to OSS',
      setShare: 'Set file as shared',
      deleteFile: 'Delete file permanently',
      downloadFile: 'Download file',
    },

    heap: {
      basicInformation: 'Basic Information',
      reanalyzePrompt: 'Do you want to continue?',
      releasePrompt: 'Do you want to continue?',
      overview: 'Overview',
      leakSuspects: 'Leak Suspects',
      description: 'Description',
      detail: 'Detail',
      GCRoots: 'GC Roots',
      systemProperty: 'System Property',
      OSBit: 'OS Bit',
      jvmInfo: 'JVM',
      heapCreationDate: 'Creation Date',
      usedHeapSize: 'Used Heap Size',
      numberOfClasses: 'Class Count',
      numberOfObjects: 'Object Count',
      numberOfClassLoaders: 'Class Loaders Count',
      numberOfGCRoots: 'GC Root Count',
      threadInfo: 'Thread Info',
      dominatorTree: 'Dominator Tree',
      histogram: 'Histogram',
      unreachableObjects: 'Unreachable Objects',
      duplicatedClasses: 'Duplicated Classes',
      classLoaders: 'Class Loaders',
      directByteBuffer: 'Direct Byte Buffer',
      compare: 'Heap File Compare',
      ref: {
        object: {
          label: 'References by Object',
          outgoing: 'outgoing references',
          incoming: 'incoming references',
        },
        type: {
          label: 'Reference by Class',
          outgoing: 'outgoing references',
          incoming: 'incoming references',
        }
      },

      pathToGCRoots: 'Path to GC Roots',
      mergePathToGCRoots: 'Merge Path to GC Roots',

      descOfKeepUnreachableObjects: 'If this option is enabled, the analyzer will treat the unreachable objects as the unreachable roots, and then analyze the reference relationship in them. Otherwise, no further analysis will be performed on the unreachable objects, but only the statistics of types of the unreachable object, that is Unreachable Objects Histogram',
      descOfStrictness: '\'strictness\' indicates the follow-up action when an error occurred',
      descOfStopStrictness: 'Throw an error and stop analyzing the dump',
      descOfWarnStrictness: 'Raise a warning and continue',
      descOfPermissiveStrictness: 'Raise a warning and try to "fix" it',
    },

    gclog: {
      gclogFile: "GC Log File",
      navigation: 'Navigation',
      navToTop: 'Top',
      gclogFilePlaceholder: "Fill with the URL of analysis page of the file. To choose the time range of analysis, please config it in the page of that file in advance. You can compare two time ranges of one GC log.",
      stwTooltip: "The Java program stops the world in this phase",
      analysisConfig: 'Analysis Config',
      gclogCompare: 'Compare GC Logs',
      logTimeRange: "Time range covered by the log",
      analysisTimeRange: "Current analysis time range",
      duration: "Duration",
      analysisTimeRangeChooseHint: "Choose a time range you are concerned with to analyze",
      analysisTimeRangeLength: "Duration of analysis time range",
      metric: "Metric",
      metricCompare: "Metric Comparison",
      parallelGCThreads: 'Parallel GC Threads',
      parallelGCThreadsHint: "Parallel GC threads(correspond to option -XX:ParallelGCThreads) deals with work in pause phases, Increasing parallel gc threads number may decrease pause time. Remember not to set it more than the number of CPUs.",
      concurrentGCThreads: 'Concurrent GC Threads',
      concurrentGCThreadsHint: 'Concurrent GC threads(correspond to option-XX:ConcGCThreads) deals with work in current phases. Increasing concurrent gc threads may accelerate concurrent gc work but increase cpu ',
      gcDetail: 'GC Details',
      applyTimeToConfig: "Apply current time range of graph to the whole page",
      noDatestampPreunified: 'Datestamp is not printed in the log so we have to choose time based on the uptime，It is recommended to add option -XX:+PrintGCDateStamps to print datestamp.',
      noDatestampUnified: 'Datestamp is not printed in the log so we have to choose time based on the uptime. It is recommended to set gc log printing option like "-Xlog:gc*:file=gc.log:time,uptime,level,tags" (add "time" to decoration) to print datestamp..',
      longPauseThreshold: 'Long Pause Threshold(ms)',
      longPauseThresholdHint: 'Pause phases with duration longer than this will be seen as long pause',
      youngGCFrequentIntervalThreshold: 'Young GC Interval Threshold(ms)',
      youngGCFrequentIntervalThresholdHint: 'Young GC will be seen as frequent if the interval of two adjacent Young GC is shorter than this time.',
      oldGCFrequentIntervalThreshold: 'Old GC Interval Threshold(ms)',
      oldGCFrequentIntervalThresholdHint: 'Old GC will be seen as frequent if the interval of two adjacent Old GC is shorter than this time.',
      fullGCFrequentIntervalThreshold: 'Full GC Interval Threshold(ms)',
      fullGCFrequentIntervalThresholdHint: 'Full GC will be seen as frequent if the interval of two adjacent Full GC is shorter than this time.',
      fullGCForNongenerational: 'All gcs are regarded as Full GC because {gc} is not generational.',


      basicInfo: 'Basic Information',
      collector: "Collector",
      objectStats: 'Object Statistics',
      objectCreationSpeed: "Object Creation Speed",
      objectPromotionSpeed: "Object Promotion Speed",
      objectPromotionAvg: "Average Object Promotion",
      objectPromotionMax: "Max Object Promotion",

      pauseInfo: {
        pauseInfo: "Pause Info",
        pauseDistribution: "Pause Time Distribution",
        throughput: "GC Throughput",
        throughputHint: "GC throughput is time spend in real transaction/total time. Higher gc throughput means lower gc overhead.",
        pauseAvg: "Average Pause",
        pauseMax: "Max Pause",
        pauseMedian: "Median Pause",
        pauseTime: "Pause Time",
        pauseCount: "Pause Count"
      },

      memoryStats: {
        memoryStats: "Heap And Metaspace",
        memoryArea: "Memory Area",
        capacityAvg: "Average Capacity",
        capacityAvgHint: "Capacity of an area is total size of objects can be allocated in this area. Average capacity may be smaller than max used because capacity can be dynamic. For example, when -Xmx!=-Xms, the heap may shrink or expand and young and generation will shrink or expanding accordingly.",
        g1DynamicCapacity: "In addition, for G1 even if -Xmx=-Xms, if -Xmn is not set(and -Xmn is not recommended to set), capacity of young and old generation are dynamic.",
        usedMax: "Max Used",
        usedMaxHint: "Can be used to evaluate the RSS of the Java process. The RSS of heap is close to the max used memory of heap.",
        usedAvgAfterFullGC: "Average Used After Full GC",
        usedAvgAfterFullGCHint: "Can be used to evaluate the live set of this area. A high value could mean a memory leak.",
        usedAvgAfterOldGC: "Average Used After Old GC",
        usedAvgAfterOldGCHint: "Can be used to evaluate the live set of this area. A high value could mean a memory leak.",
        metaspaceCapacity: 'Notice that information printed in original gc log like "Metaspace: 1792694K->291615K(698368K)" means the reserve space of metaspace is 698368K rather than capacity of metaspace.',
        youngCapacityAvg: 'Young Gen Avg Capacity',
        youngUsedMax: 'Old Gen Max Used',
        oldCapacityAvg: "Old Gen Avg Capacity",
        oldUsedMax: "Old Gen Max Used",
        oldUsedAvgAfterFullGC: "Old Gen Avg Used After Full GC",
        oldUsedAvgAfterOldGC: "Old Gen Avg Used After Old GC",
        humongousUsedMax: "Humongous Max Used",
        humongousUsedAvgAfterFullGC: "Humongous Avg Used After Full GC",
        humongousUsedAvgAfterOldGC: "Humongous Avg Used After Old GC",
        heapCapacityAvg: "Heap Avg Capacity",
        heapUsedMax: "Heap Max Used",
        heapUsedAvgAfterFullGC: "Heap Avg Used After Full GC",
        heapUsedAvgAfterOldGC: "Heap Avg Used After Old GC",
        metaspaceCapacityAvg: "Metaspace Avg Capacity",
        metaspaceUsedMax: "Metaspace Max Used",
        metaspaceUsedAvgAfterFullGC: "Metaspace Avg Used After Full GC",
        metaspaceUsedAvgAfterOldGC: "Metaspace Avg Used After Old GC",
      },

      phaseStats: {
        phaseStatsAndCause: "Phase And Cause",
        phaseStats: "Phase Statistics",
        importantMode: "Important Phases Only",
        pauseMode: "Pause Phases Only",
        structuredMode: "Display By Phase Hierarchy",
        causeMode: "Display By GC Cause",
        name: "Name",
        count: "Count",
        intervalAvg: "Average Interval",
        intervalMin: "Min Interval",
        durationAvg: "Average Duration",
        durationMax: "Max Duration",
        durationTotal: "Total Duration",
        youngGCCount: 'Young GC Count',
        youngGCIntervalAvg: 'Young GC Average Interval',
        youngGCDurationAvg: 'Young GC Average Duration',
        youngGCDurationMax: 'Young GC Max Duration',
        mixedGCCount: 'Mixed GC Count',
        mixedGCIntervalAvg: 'Mixed GC Average Interval',
        mixedGCDurationAvg: 'Mixed GC Average Duration',
        mixedGCDurationMax: 'Mixed GC Max Duration',
        oldGCCount: 'Old GC Count',
        oldGCIntervalAvg: 'Old GC Average Interval',
        oldGCDurationAvg: 'Old GC Average Duration',
        oldGCDurationMax: 'Old GC Max Duration',
        fullGCCount: 'Full GC Count',
        fullGCIntervalAvg: 'Full GC Average Interval',
        fullGCDurationAvg: 'Full GC Average Duration',
        fullGCDurationMax: 'Full GC Max Duration',
      },

      generation: {
        young: "Young Generation",
        old: "Old Generation",
        humongous: "Metaspace",
        humongousHint: "Humongous objects in G1 refer to objects with size larger than half region size(correspond to option -XX:G1HeapRegionSize). Too many humongous objects may lead to problems and the solution is to enlarge region size or create less humongous object,",
        heap: "Heap",
        metaspace: "Metaspace",
      },

      vmOptions: {
        vmOptions: "JVM Options",
        unknown: "Not reported in the log",
        gcRelatedOptions: "GC Related Options",
        otherOptions: "Other Options",
      },

      timeGraph: {
        timeGraph: 'Time Graph',
        fullScreen: 'Toggle full screen display',
        durationOf: '{type} Duration',
        youngCapacity: 'Young Gen Capacity',
        oldUsed: 'Old Gen Used',
        oldCapacity: 'Old Gen Capacity',
        humongousUsed: 'Humongous Used',
        heapUsed: 'Heap Used',
        heapCapacity: 'Heap Capacity',
        metaspaceUsed: 'Metaspace Used',
        metaspaceCapacity: 'Metaspace Capacuty',
        reclamation: 'Reclamation',
        promotion: 'Promotion',
      },

      cause: {
        systemgc: 'Triggered when System.gc() or Runtime.getRuntime().gc() is called.',
        jvmti: "Triggered whenForceGarbageCollection is called using JVMTI.",
        gclocker: 'When a thread is in JNI critical section and a gc is triggered，GC Locker will prevent this gc from executing and prevent other threads from entering critical section.  When the last thread exits the critical section, GCLocker Initiated GC is triggered. Heavy use of GC Locker may prevent gcs from occurring timely, lead to long pause or even Full GC.',
        heapInspection: 'Triggered by heap inspection operation(such as jmap).',
        heapDump: 'Triggered by heap dump operation.',
        allocationFail: 'Triggered when there is insufficient space to allocate object.',
        metaspace: 'Full gc is triggered when there is insufficient space in Metaspace. Notice that allocation request in metaspace may fail even if it seems not full because of fragmentation in metaspace.',
        ergonomics:'Triggered in order to adjust heap size dynamically to meet a specified goal such as minimum pause time or throughput.',
        g1Evacuation:'Triggered when there is insufficient space to allocate object.',
        humongous: 'Full GC is triggered when there is insufficient space to allocate humongous object.',
        lastDitch: 'After Metadata GC Threshold GC, JVM will trigger another Full GC and clear soft reference if allocation request in metaspace failed.',
        promotionFail: 'During young gc，if there is not sufficient space in tenured generation for promotion, this gc will become an expensive Full GC.',
        toSpaceExhausted: 'To-space exhausted means there is not sufficient region for promotion or as to space during young/mixed gc. This may lead to failure to reclaim space during gc, high object promotion and long gc pause',
        proactive: 'JVM actively triggers a gc to reduce heap usage. Typically triggered when object allocation rate is low.',
        allocationRate: 'Triggered when JVM estimates that heap will be used up according to the current object allocation rate.',
        timer: "If -XX:ZCollectionInterval is set，a periodic gc is triggered when no gc has been triggered for such time.",
        allocationStall: 'Triggered when heap is used up.',
        highUsage: 'Triggered when heap usage is higher than a specific percent.',
        warmup: 'After JVM starts up, if no other gcs are triggered, three gcs will triggered when heap usage is higher than 10%, 20% and 30%.',
        metaspaceClearSoftRef: 'After Metadata GC Threshold GC, JVM will trigger another Full GC and clear soft reference if allocation request in metaspace failed.',
        g1Periodic: "If -XX:G1PeriodicGCInterval is set，a periodic gc is triggered when no gc has been triggered for such time. This feature is typically used to reclaim heap memory.",
        dcmd: "Full gc triggered by jcmd",
        g1Compaction: "Full gc triggered by jcmd.",
        g1Preventive: 'Triggered to prevent "to-space exhausted".',
      },

      diagnose: {
        diagnose: "Diagnose",
        noProblem: "No problem detected",
        problemTemplate: "In {time}, there is {problem}.",
        solution: "Common ways for troubleshooting or tuning:",
        abnormal: {
          outOfMemory: "Out of Memory",
          allocationStall: "Allocation Stall",
          metaspaceFullGC: "Full GC caused by metaspace",
          heapMemoryFullGC: "Full GC caused by heap",
          longYoungGCPause: "Young GC long pause",
          systemGC: "Full GC caused by System.gc()",
        },
        suggestion: {
          upgradeTo11G1FullGC: "If there is no way to eliminate Full GC or Full GC is acceptable，upgrading to G1 in JDk11 may reduce pause time with the help of multi thread optimization in Full GC.",
          checkSystemGC: "Check where System.gc() is called and if it is necessary",
          disableSystemGC: "Add option -XX:+DisableExplicitGC to disable System.gc()",
          oldSystemGC: "Or add option -XX:+ExplicitGCInvokesConcurrent to make System.gc() call trigger a concurrent Old GC",
          checkMetaspace: "Check what is metaspace filled with",
          enlargeMetaspace: "Increase -XX:MetaspaceSize -XX:MaxMetaspaceSize to enlarge metaspace",
          enlargeHeap: "Increase -Xmx -Xms to enlarge metaspace",
          increaseConcGCThreads: "Increase -XX:ConcGCThreads to use more concurrent gc threads",
          decreaseIHOP: "Decrease option -XX:InitiatingHeapOccupancyPercent to trigger Old GC earlier",
          decreaseCMSIOF: "Decrease option -XX:CMSInitiatingOccupancyFraction to trigger Old GC earlier",
          increaseZAllocationSpikeTolerance: "Increase -XX:ZAllocationSpikeTolerance to trigger GC earlier",
          checkLiveObjects: "If too many objects survived after gc, check application logic to see why there are so many survivors.",
          checkReferenceGC: "If reference processing time long，enable -XX:+ParallelRefProcEnabled for multi thread optimization(enabled by default after JDK11)，or check why there are so many weak/soft/phantom references",
          checkCPUTime: "Check CPU Time. If real is long but usr，sys are short，this may be owing to disk I/O or interference between processes or containers.",
          shrinkYoungGen: "Decrease -Xmn to shrink young generation capacity",
          shrinkYoungGenG1: "Decrease -XX:G1MaxNewSizePercent to shrink young generation capacity",
          checkEvacuationFailure: "Check if there is To-space exhausted during. If there is, one way is not to set -Xmn option and the other way is to check if there is too many humongous object allocation, memory leak or early promotion.",
          checkMemoryLeak: "Check if there is memory leak by means of Heap Dump etc.",
          checkFastPromotion: "If memory used in old generation increases rapidly before the full gc，check if there is early promotion led by long life cycle objects by means of Heap Dump before Full GC.",
        }
      },

      detail: {
        filters: "Filters",
        eventType: "GC Event Type",
        logTime: "Log Time",
        pauseTime: "Pause Time",
      },
    },

    threadDump: {
      title: "Thread Dump Analysis",
      addFile: "Add Thread Dump File",
      overview: 'Overview',
      lockView: 'Lock View',
      basicInfo: 'Basic Information',
      time: 'Time',
      vmInfo: 'VM Information',
      jniRefs: 'JNI References',
      jniWeakRefs: 'JNI Weak References',
      errorPrompt: 'Number of errors found during parsing: ',
      deadLockCount: 'Dead Lock Count',
      threadSummary: "Thread Summary",
      threadGroupSummary: "Thread Group Summary",
      javaThread: "Java Thread",
      jitThread: "JIT Thread",
      gcThread: "GC Thread",
      otherThread: "Other Thread",
      total: "Total",
      callSiteTree: "Call Site Tree",
      fileContent: "File Content",
      loadFileContent: "Load",
      loadMoreFileContent: "Load More",
      threadNameLabel: "Thread Name",
    }
  }
};
